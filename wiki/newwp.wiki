#summary : Instructions on how to add a new waypoint to DataPath

= Overall Plan =

To add a new waypoint to DataPath, 4 separate tasks need to be accomplished. The parser needs to be changed, the translator needs to know how to include the new waypoint into analysis, the WayPoint code that runs in the execution engine needs to establish the data flow while the operator is running and the patterns for code generation have to specify the code that is executed by the workers.

Throughout this document we use the GLAWaypoint as a running example. This waypoint adds GLA execution capabilities to DataPath. GLAs are a generalization of User Defined Aggregates. Any GLA type is assumed to have the following methods:
  * A constructor, with at most 1 argument: `ConstState&` 
  * `AddItem(const T1& v1, const T2& v2, ...)`, a method to add a piece of information to the state of the GLA. 
  * `AddState(GLA& other)`, a method to merge content of other into this state
  * Optionally, a mechanism to extract result in the form 1 tuple: through the function `GetResult(T1& t1, T2& t2, ...)`
  * Optionally, a mechanism to extract, 0 or more tuples: `bool GetNext(T1& v1,...)`
  * Optionally, a method to serialize-deserialize the GLA so that it can be transported into user space

*Example of GLA*: Average

{{{
class AverageGLA {
  long long int count; // keeps the number of tuples aggregated
  double sum; // sum of the values 
public:  
  AverageGLA(){ count=0; sum=0.0; }
  AddItem(const DOUBLE& x){ count++; sum+=x; }
  AddState(AverageGLA& o){ count+=o.count; sum+=o.sum; }
  // we only support one tuple as output
  GetResult(DOUBLE& rez){ rez = (count>0) ? (sum/count) : 0.0;}
};

}}} 

*NOTE*: GLAs are used as syntactic objects. There is no need to inherit from any class since the system uses code generation to produce the functions that are executed. The GLAs should be written as compactly/efficiently as possible. 

*WARNING*: Inheritance and other C++ abstractions are *evil* and kill performance.

== Changes to the parser ==

The parser is in `LemonTranslator/parser` directory. We need to decide how to extend the syntax of of the .dp files. A good starting point is the syntax for aggregates, that is close in spirit. We first need to specify connectivity and type. Like the Aggregate, GLA waypoints are non-terminating.

{{{
new scanner lineitem;
new waypoint ll = Select :-lineitem;
new waypoint gla = GLA :- ll; 
new waypoint pr = Print :- ?gla;
}}}

The above code specifies that we are  reading `lineitem`, apply selection than send tuples to the GLA. Once done, we print the result. This means that the GLA should produce tuples. If we want to move the GLA state to the users space, we can introduce a new waypoint that allows that

{{{
new waypoint st = TransmitState :- ?gla;
}}}

For the specification of the behavior of the GLA waypoint, we can use something like this:

{{{
new query Q1, Q2;
waypoint gla {
  query Q1 { 
    gla (r:DOUBLE) = AverageGLA( lineitem_l_discount );
  }
  query Q2 {
    gla (a:DOUBLE,b:INT,c:VARCHAR) = MyGla( lineitem_l_discount, lineitem_l_comment); 
  }
}

waypoint pr {
  query Q1 { print r; }
  query Q2 { print a,b,c; }
}
}}}

The line `gla (r:DOUBLE) = AverageGLA( lineitem_l_discount );` specifies that for `Q1` we have to use GLA `AverageGLA` for which the `AddItem()` function takes as argument expression `lineitem_l_discount`. The GLA will produce a tuple that consists of a single `DOUBLE`, called `r`. A larger set of expressions and a larger set of results can be obtained. 

*NOTE* each query can have a different behavior. The system should allow that but it might be useful to have very different behavior. By using different GLAs for different queries, we can evaluate multiple things over the scan of the input. This could significantly improve the performance. Different things should go in different waypoints.

The code above is sufficient to allow the correct code generation as long as the GLAs used are compatible. To perform a type check, we need a GLAManager and type specifier. This is discussed in another place [GLAManager].

To change the parser we need to add code in  `LemonTranslator/parser/DataPath.g` to specify the new syntax. Most of the hard work is already done, we can simply just mimic the behavior of aggregate. The code in `DataPath.g` must call the API that we still need to introduce to specify GLA waypoints. 

*NOTE*: Expressions, list of attributes, etc, are already supported. We can just reuse the facility. The only slightly different feature is specification of the form `a:DOUBLE` that specify a name and a type. 

The only change needed in `LemonTranslator/parser/DPTree.g` is the specification of the content of the GLA waypoint. Again we can mimic the behavior of Aggregate.




